#pragma once

// Copyright 2014 Stellar Development Foundation and contributors. Licensed
// under the Apache License, Version 2.0. See the COPYING file at the root
// of this distribution or at http://www.apache.org/licenses/LICENSE-2.0

#include "lib/json/json-forwards.h"
#include "icp/ICP.h"
#include <functional>
#include <memory>
#include <set>
#include <string>
#include <utility>

namespace iotchain
{
class Node;
class Slot;

// used to filter statements
typedef std::function<bool(ICPStatement const& st)> StatementPredicate;

/**
 * The Slot object is in charge of maintaining the state of the ICP protocol
 * for a given slot index.
 */
class BallotProtocol
{
    Slot& mSlot;

    bool mHeardFromQuorum;

    // state tracking members
    enum ICPPhase
    {
        ICP_PHASE_PREPARE,
        ICP_PHASE_CONFIRM,
        ICP_PHASE_EXTERNALIZE,
        ICP_PHASE_NUM
    };
    // human readable names matching ICPPhase
    static const char* phaseNames[];

    std::unique_ptr<ICPBallot> mCurrentBallot;      // b
    std::unique_ptr<ICPBallot> mPrepared;           // p
    std::unique_ptr<ICPBallot> mPreparedPrime;      // p'
    std::unique_ptr<ICPBallot> mHighBallot;         // h
    std::unique_ptr<ICPBallot> mCommit;             // c
    std::map<NodeID, ICPEnvelope> mLatestEnvelopes; // M
    ICPPhase mPhase;                                // Phi
    std::unique_ptr<Value> mValueOverride;          // z

    int mCurrentMessageLevel; // number of messages triggered in one run

    std::shared_ptr<ICPEnvelope>
        mLastEnvelope; // last envelope generated by this node

    std::shared_ptr<ICPEnvelope>
        mLastEnvelopeEmit; // last envelope emitted by this node

  public:
    BallotProtocol(Slot& slot);

    // Process a newly received envelope for this slot and update the state of
    // the slot accordingly.
    // self: set to true when node feeds its own statements in order to
    // trigger more potential state changes
    ICP::EnvelopeState processEnvelope(ICPEnvelope const& envelope, bool self);

    void ballotProtocolTimerExpired();
    // abandon's current ballot, move to a new ballot
    // at counter `n` (or, if n == 0, increment current counter)
    bool abandonBallot(uint32 n);

    // bumps the ballot based on the local state and the value passed in:
    // in prepare phase, attempts to take value
    // otherwise, no-ops
    // force: when true, always bumps the value, otherwise only bumps
    // the state if no value was prepared
    bool bumpState(Value const& value, bool force);
    // flavor that takes the actual desired counter value
    bool bumpState(Value const& value, uint32 n);

    // ** status methods

    // returns information about the local state in JSON format
    // including historical statements if available
    Json::Value getJsonInfo();

    // returns information about the quorum for a given node
    Json::Value getJsonQuorumInfo(NodeID const& id, bool summary,
                                  bool fullKeys = false);

    // returns the hash of the QuorumSet that should be downloaded
    // with the statement.
    // note: the companion hash for an EXTERNALIZE statement does
    // not match the hash of the QSet, but the hash of commitQuorumSetHash
    static Hash getCompanionQuorumSetHashFromStatement(ICPStatement const& st);

    // helper function to retrieve b for PREPARE, P for CONFIRM or
    // c for EXTERNALIZE messages
    static ICPBallot getWorkingBallot(ICPStatement const& st);

    ICPEnvelope*
    getLastMessageSend() const
    {
        return mLastEnvelopeEmit.get();
    }

    void setStateFromEnvelope(ICPEnvelope const& e);

    std::vector<ICPEnvelope> getCurrentState() const;

    // returns the latest message from a node
    // or nullptr if not found
    ICPEnvelope const* getLatestMessage(NodeID const& id) const;

    std::vector<ICPEnvelope> getExternalizingState() const;

  private:
    // attempts to make progress using the latest statement as a hint
    // calls into the various attempt* methods, emits message
    // to make progress
    void advanceSlot(ICPStatement const& hint);

    // returns true if all values in statement are valid
    ICPDriver::ValidationLevel validateValues(ICPStatement const& st);

    // send latest envelope if needed
    void sendLatestEnvelope();

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the ICP paper
    bool attemptAcceptPrepared(ICPStatement const& hint);
    // prepared: ballot that should be prepared
    bool setAcceptPrepared(ICPBallot const& prepared);

    // step 2+3+8 from the ICP paper
    // ballot is the candidate to record as 'confirmed prepared'
    bool attemptConfirmPrepared(ICPStatement const& hint);
    // newC, newH : low/high bounds prepared confirmed
    bool setConfirmPrepared(ICPBallot const& newC, ICPBallot const& newH);

    // step (4 and 6)+8 from the ICP paper
    bool attemptAcceptCommit(ICPStatement const& hint);
    // new values for c and h
    bool setAcceptCommit(ICPBallot const& c, ICPBallot const& h);

    // step 7+8 from the ICP paper
    bool attemptConfirmCommit(ICPStatement const& hint);
    bool setConfirmCommit(ICPBallot const& acceptCommitLow,
                          ICPBallot const& acceptCommitHigh);

    // step 9 from the ICP paper
    bool attemptBump();

    // computes a list of candidate values that may have been prepared
    std::set<ICPBallot> getPrepareCandidates(ICPStatement const& hint);

    // helper to perform step (8) from the paper
    bool updateCurrentIfNeeded(ICPBallot const& h);

    // An interval is [low,high] represented as a pair
    using Interval = std::pair<uint32, uint32>;

    // helper function to find a contiguous range 'candidate' that satisfies the
    // predicate.
    // updates 'candidate' (or leave it unchanged)
    static void findExtendedInterval(Interval& candidate,
                                     std::set<uint32> const& boundaries,
                                     std::function<bool(Interval const&)> pred);

    // constructs the set of counters representing the
    // commit ballots compatible with the ballot
    std::set<uint32> getCommitBoundariesFromStatements(ICPBallot const& ballot);

    // ** helper predicates that evaluate if a statement satisfies
    // a certain property

    // is ballot prepared by st
    static bool hasPreparedBallot(ICPBallot const& ballot,
                                  ICPStatement const& st);

    // returns true if the statement commits the ballot in the range 'check'
    static bool commitPredicate(ICPBallot const& ballot, Interval const& check,
                                ICPStatement const& st);

    // attempts to update p to ballot (updating p' if needed)
    bool setPrepared(ICPBallot const& ballot);

    // ** Helper methods to compare two ballots

    // ballot comparison (ordering)
    static int compareBallots(std::unique_ptr<ICPBallot> const& b1,
                              std::unique_ptr<ICPBallot> const& b2);
    static int compareBallots(ICPBallot const& b1, ICPBallot const& b2);

    // b1 ~ b2
    static bool areBallotsCompatible(ICPBallot const& b1, ICPBallot const& b2);

    // b1 <= b2 && b1 !~ b2
    static bool areBallotsLessAndIncompatible(ICPBallot const& b1,
                                              ICPBallot const& b2);
    // b1 <= b2 && b1 ~ b2
    static bool areBallotsLessAndCompatible(ICPBallot const& b1,
                                            ICPBallot const& b2);

    // ** statement helper functions

    // returns true if the statement is newer than the one we know about
    // for a given node.
    bool isNewerStatement(NodeID const& nodeID, ICPStatement const& st);

    // returns true if st is newer than oldst
    static bool isNewerStatement(ICPStatement const& oldst,
                                 ICPStatement const& st);

    // basic sanity check on statement
    bool isStatementSane(ICPStatement const& st, bool self);

    // records the statement in the state machine
    void recordEnvelope(ICPEnvelope const& env);

    // ** State related methods

    // helper function that updates the current ballot
    // this is the lowest level method to update the current ballot and as
    // such doesn't do any validation
    // check: verifies that ballot is greater than old one
    void bumpToBallot(ICPBallot const& ballot, bool check);

    // switch the local node to the given ballot's value
    // with the assumption that the ballot is more recent than the one
    // we have.
    bool updateCurrentValue(ICPBallot const& ballot);

    // emits a statement reflecting the nodes' current state
    // and attempts to make progress
    void emitCurrentStateStatement();

    // verifies that the internal state is consistent
    void checkInvariants();

    // create a statement of the given type using the local state
    ICPStatement createStatement(ICPStatementType const& type);

    // returns a string representing the slot's state
    // used for log lines
    std::string getLocalState() const;

    std::shared_ptr<LocalNode> getLocalNode();

    bool federatedAccept(StatementPredicate voted, StatementPredicate accepted);
    bool federatedRatify(StatementPredicate voted);

    void startBallotProtocolTimer();
    void stopBallotProtocolTimer();
    void checkHeardFromQuorum();
};
}
